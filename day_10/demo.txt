Generators in Python
Last Updated : 29 Jul, 2025
A generator function is a special type of function that returns an iterator object. Instead of using return to send back a single value, generator functions use yield to produce a series of results over time. This allows the function to generate values and pause its execution after each yield, maintaining its state between iterations.

Example:
def fun(max):
    cnt = 1
    while cnt <= max:
        yield cnt
        cnt += 1
​
ctr = fun(5)
for n in ctr:
    print(n)

Output
1
2
3
4
5
Explanation: This generator function fun yields numbers from 1 up to a specified max. Each call to next() on the generator object resumes execution right after the yield statement, where it last left off.

Why Do We Need Generators?
Memory Efficient : Handle large or infinite data without loading everything into memory.
No List Overhead : Yield items one by one, avoiding full list creation.
Lazy Evaluation : Compute values only when needed, improving performance.
Support Infinite Sequences : Ideal for generating unbounded data like Fibonacci series.
Pipeline Processing : Chain generators to process data in stages efficiently.
Let's take a deep dive in python generators:

Creating Generators
Creating a generator in Python is as simple as defining a function with at least one yield statement. When called, this function doesn’t return a single value; instead, it returns a generator object that supports the iterator protocol. The generator has the following syntax in Python:

def generator_function_name(parameters):
    # Your code here
    yield expression
    # Additional code can follow

Example: we will create a simple generator that will yield three integers. Then we will print these integers by using Python for loop.